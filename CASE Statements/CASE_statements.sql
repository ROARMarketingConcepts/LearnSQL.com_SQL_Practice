-- Display the play name and the category name (name the column with the category name tickets_sold_category).

-- tickets_sold_category is based on the total number of tickets sold for all events that staged a given play. 
-- The categories are as follows:

-- Less than or equal to 50 tickets sold – '50_or_less'.
-- More than 50 tickets and less than or equal to 100 tickets – '50_to_100'.
-- More than 100 tickets and less than or equal to 200 tickets – '100_to_200'.
-- More than 200 tickets – 'more_than_200'.


select name, --sum(tickets_sold),
case
	when sum(tickets_sold) <= 50 then '50_or_less'
    when sum(tickets_sold) <= 100  then '50_to_100'
    when sum(tickets_sold) <= 200 then '100_to_200'
    else 'more_than_200' end as tickets_sold_category
from event e
left join play p
on e.play_id=p.id
group by 1


-- Before we introduce free shipping to the USA and Canada, we'd 
-- ike to know how many orders are sent to these countries and how 
-- many are sent to other places. Take a look:

SELECT 
  CASE
    WHEN ship_country = 'USA' OR ship_country = 'Canada' THEN 0.0
    ELSE 10.0
  END AS shipping_cost,
  COUNT(*) AS order_count
FROM orders
GROUP BY
  CASE
    WHEN ship_country = 'USA' OR ship_country = 'Canada' THEN 0.0
    ELSE 10.0
  END;


-- In the SELECT clause, we used the CASE WHEN construction you've seen before. 
-- However, you can also see that the same CASE WHEN construction appears in the 
-- GROUP BY clause, only without the shipping_cost alias. Even though we already 
-- defined it in the SELECT clause and gave it an alias (shipping_cost), most 
-- databases don't allow referring to an alias in the GROUP BY clause (i.e., 
-- we can't write GROUP BY shipping_cost). That's why we had to repeat the whole 
-- construction. (Note that some databases, like PostgreSQL or MySQL, allow us to 
-- refer to column aliases in GROUP BY. However, this is a feature of these databases. 
-- The standard SQL doesn't allow it. It's best to know how to write the correct query 
-- in both cases.)

-----------------------------------------------------------------------------------------

-- Count the orders processed by employees from the 'WA' region and by all other employees. 
-- Show two columns: employee_region (either 'WA' or 'Not WA'), and order_count.

WITH region_counts AS 

(SELECT e.region,
  COUNT(CASE WHEN e.region='WA' THEN order_id ELSE NULL END) AS wa_count,
  COUNT(CASE WHEN e.region<>'WA' OR e.region IS NULL THEN order_id ELSE NULL END) AS non_wa_count
FROM orders o
LEFT JOIN employees e
ON o.employee_id=e.employee_id
GROUP BY 1)

SELECT 
  CASE WHEN region='WA' THEN 'WA' ELSE 'Not WA' END AS employee_region,
  CASE WHEN region='WA' THEN wa_count ELSE non_wa_count END as order_count
FROM region_counts


------------------------------------------------------------------------

-- For each ship_country, we want to see the percentage of revenue for all orders before discount 
-- that has been generated by the employees with the IDs 1 and 2. Show three columns:

-- The country to which an order is being shipped (ship_country).
-- percentage_employee_1 – the percentage of pre-discount revenue generated by the employee with ID 1.
-- percentage_employee_2 – the percentage of pre-discount revenue generated by the employee with ID 2.
-- Round the percentages to two decimal places.

WITH country_totals AS 

(SELECT ship_country, 
  CASE WHEN employee_id=1 THEN SUM(quantity*unit_price) ELSE 0 END AS employee_1_revenue,
  CASE WHEN employee_id=2 THEN SUM(quantity*unit_price) ELSE 0 END AS employee_2_revenue,
    SUM(quantity*unit_price) OVER(PARTITION BY ship_country) AS total_revenue
FROM orders o
LEFT JOIN order_items oi
ON o.order_id=oi.order_id
GROUP BY 1, o.employee_id, oi.quantity,oi.unit_price
ORDER BY 1)

SELECT ship_country, 
ROUND(SUM(employee_1_revenue)/total_revenue*100,2) AS percentage_employee_1,
ROUND(SUM(employee_2_revenue)/total_revenue*100,2) AS percentage_employee_2
FROM country_totals
GROUP BY 1, total_revenue


